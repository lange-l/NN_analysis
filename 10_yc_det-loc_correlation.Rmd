---
title: "det-loc_correlation"
author: "Lena Lange"
date: "2023-08-22"
output: html_document
---

Calculate det_perf & loc_perf per block
A) plot within-subject means of loc_perf against det_perf
B) plot loc_perf against det_perf for all blocks individually

#### Packages, settings, data frame

```{r setup, include=FALSE}

.libPaths("/data/pt_02438/lena/R/") # set path to save packages
library(tidyverse)
library(ggpubr)

options(scipen = 999) # turn off e notation

palette <- c("#F8766D", "#0072C1", "#EFC000")

data_dir <- '/data/pt_02438/numbtouch_neglect/young_controls/yc_behav/'
plot_dir <- '/data/pt_02438/numbtouch_neglect/young_controls/yc_behav/plots/'

behav_data <- paste(data_dir, 'yc_behav_excl.csv', sep = '')
df <- read.table(behav_data, header = TRUE, sep = ",", fill = TRUE, stringsAsFactors = FALSE) 

df <- subset(df, ID!=28, 
             select=c(ID, block, miniblock, block_type, stim, resp1, resp2, det, loca)) %>%
  mutate(
    acc_det = 'Na',
    acc_det = as.integer((stim!=0 & resp1==1) | (stim==0 & resp1==0)),
    
    acc_loc = as.integer((stim==1 & resp2==1) | (stim==2 & resp2==2)),
    acc_loc = ifelse(loca=="catch", "catch", acc_loc),
    acc_loc = as.numeric(acc_loc),
    
    det_perf = 'Na',
    det_perf = as.numeric(det_perf),
    loc_perf = 'Na',
    loc_perf = as.numeric(loc_perf)
    )

```

#### Calculate detection performances, localisation performances, and within-subject averages

```{r}
for (i in unique(df$ID)) { # iterate over participants
  df_ID <- subset(df, ID==i)

  for (j in unique(df_ID$block)){   # iterate over blocks of current participant
    df_block <- subset(df_ID, block==j)
    
    df_loc <- subset(df_block, acc_loc!="catch") # excl catch trials to calc loc_perf
    
    df <- df %>% # calc. det_perf & loc_perf of current block, write into df
        mutate(
          det_perf = ifelse(((ID == i) & (block == j)), mean(df_block$acc_det), det_perf),
          loc_perf = ifelse(((ID == i) & (block == j)), mean(df_loc$acc_loc), loc_perf)
        )
}}

remove(df_ID, df_block, df_loc)

# summarise 
df_sum <- df %>%
  group_by(ID, block, det_perf, loc_perf) %>%
  summarise() 

# take within-subject averages
df_av <- df_sum %>%
  group_by(ID) %>%
  summarise(det_perf = mean(det_perf),
            loc_perf = mean(loc_perf)) 


```

#### Plot distribution of ID correlation coefficents

```{r}

cor_sum <- df_sum %>%
  group_by(ID) %>%
  summarize(correlation = cor(loc_perf, det_perf, use = "complete.obs"))

print(summary(cor_sum$correlation))
#    Min.  1st Qu.  Median    Mean  3rd Qu.    Max.      SD
# -0.5914   0.5183  0.7986  0.6925   0.9560  1.0000  0.3767

# Create a histogram of within-ID correlations
sum_plot <- ggplot(cor_sum, aes(x = correlation))+
  geom_histogram(binwidth = 0.15, fill = "lightblue", color = "black")+
  labs(x = "Within-ID Correlation of Detection Performance & Localisation Performance", y = "Frequency", title = "Distribution of Within-ID Correlations")+ 
  xlim(0,1)


# overall correlation coefficient
corr_coef <- cor(df_av$det_perf, df_av$loc_perf)
```

#### Plot scatter plots with regression line (within-subject averaged vs pooled data)

```{r}
### Averaged Data:
######################
# Fit a linear regression model
lm_model <- lm(loc_perf ~ det_perf, data = df_av)

# Get the coefficients of the linear regression model
intercept <- coef(lm_model)[1]
slope <- coef(lm_model)[2]

# Construct the equation of the line
equation <- paste("y =", round(slope, 2), "* x +", round(intercept, 2))

# Create scatter plot + linear regression line + lm equation
av_plot <- ggplot(df_av, aes(x = det_perf, y = loc_perf)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +  # Add a linear regression line
  labs(x = "Detection performance [%]", y = "Localisation performance [%]", title = "") +
  annotate("text", x = max(df_av$det_perf), y = max(df_av$loc_perf),
           label = equation, hjust = 1, vjust = 1, color = "blue")


### Pooled Data:
######################
# Fit a linear regression model
lm_model <- lm(loc_perf ~ det_perf, data = df_sum)

# Get the coefficients of the linear regression model
intercept <- coef(lm_model)[1]
slope <- coef(lm_model)[2]

# Construct the equation of the line
equation <- paste("y =", round(slope, 2), "* x +", round(intercept, 2))

# Create scatter plot + linear regression line + lm equation
sum_plot <- ggplot(df_sum, aes(x = det_perf, y = loc_perf)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +  # Add a linear regression line
  labs(x = "Detection performance [%]", y = "Localisation performance [%]", title = "") +
  annotate("text", x = max(df_sum$det_perf), y = max(df_sum$loc_perf),
           label = equation, hjust = 1, vjust = 1, color = "blue")


### Arrange figure:
######################
fig <- ggarrange(av_plot, sum_plot,
                 labels = c("A", "B"),
                 ncol = 2, nrow = 1)

annotate_figure(fig,
                top = text_grob("Correlation of detection and localisation performance", size = 14))

```


#### (Det_perf & Loc_perf per miniblock)

```{r}

# iterate over participants
for (i in unique(df$ID)) {
  df_ID <- subset(df, ID==i)
  
  # iterate over blocks of current participant
  for (j in unique(df_ID$block)){
    df_block <- subset(df_ID, block==j)
    
      for (k in unique(df_block$miniblock)){
        df_miniblock <- subset(df_block, miniblock==k)
    
        df_loc <- subset(df_miniblock, acc_loc!="catch") %>% # excl catch trials to calc loc_perf
        mutate(acc_loc = as.numeric(acc_loc)) # set acc_loc column to numeric
        
        df <- df %>%
            mutate(
              det_perf = ifelse(((ID == i) & (block == j) & (miniblock==k)),
                                     mean(df_miniblock$acc_det), det_perf),
              
              loc_perf = ifelse(((ID == i) & (block == j) & (miniblock==k)),
                                     mean(df_loc$acc_loc), loc_perf)
            )
}}}

remove(df_ID, df_block, df_loc, df_miniblock)

# set columns to numeric
df <- df %>%
  mutate(
    det_perf = as.numeric(det_perf),
    loc_perf = as.numeric(loc_perf)
  )

# summarise 
df_sum <- df %>%
  group_by(ID, miniblock, det_perf, loc_perf) %>%
  summarise() 

#fname <- file.path(data_dir, "yc_det-loc-corr_sum.csv")
#write.csv(df_sum, fname, row.names = FALSE)

df_cor <- na.omit(df_sum)

# Calculate within-ID correlations
cor_ID <- df_cor %>%
  group_by(ID) %>%
  summarize(correlation = cor(loc_perf, det_perf, use = "complete.obs"))

print(mean(cor_ID$correlation)) # 0.4321632

# Create a histogram of within-ID correlations
ggplot(cor_ID, aes(x = correlation)) +
  geom_histogram(binwidth = 0.15, fill = "lightblue", color = "black") +
  labs(x = "Within-ID Correlation of Detection Performance & Localisation Performance", y = "Frequency", title = "Distribution of Within-ID Correlations") + 
  xlim(0,1)

# Create scatter plot
ggplot(df_cor, aes(x = det_perf, y = loc_perf)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +  # Add a linear regression line
  labs(x = "Detection Score", y = "Localisation Score", title = "Scatter Plot with Correlation")


```

